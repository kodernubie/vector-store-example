package main

import (
	"bufio"
	"context"
	"encoding/json"
	"fmt"
	"log"
	"os"
	"strings"
	"time"

	openai "github.com/kodernubie/go-openai"
)

var client *openai.Client
var assistantId string
var vectorStoreId string
var threadId string

func jsonPrint(title string, iface interface{}) {

	byt, _ := json.Marshal(iface)
	fmt.Println(title, ":\r\n", string(byt))
}

func initAssistant() {

	var defaultName = "example-assistant4"

	// check if already exist
	list, err := client.ListAssistants(context.Background(), nil, nil, nil, nil)

	if err == nil {

		for _, ast := range list.Assistants {

			if strings.EqualFold(*ast.Name, defaultName) {

				assistantId = ast.ID

				if ast.ToolResources != nil && ast.ToolResources.FileSearch != nil {

					for _, vs := range ast.ToolResources.FileSearch.VectorStoreIDs {
						vectorStoreId = vs
						break
					}
				}

				break
			}
		}
	}

	// not exist, create the assistant
	if assistantId == "" {
		retAPI, err := client.CreateAssistant(context.Background(), openai.AssistantRequest{
			Model: openai.GPT4o,
			Name:  &defaultName,
			Tools: []openai.AssistantTool{{Type: openai.AssistantToolTypeFileSearch}},
		})

		if err == nil {
			jsonPrint("new assistant", retAPI)
			assistantId = retAPI.ID
		} else {
			log.Println("Error create assistant :", err)
		}
	}

	if assistantId == "" {
		log.Panicln("unable to init assistant")
	}
}

func initVectorStore() {

	// create vector store if not created
	if vectorStoreId == "" {

		var defaultName = "example-vectorstore4"

		retVS, err := client.CreateVectorStore(context.Background(), openai.VectorStoreRequest{
			Name: defaultName,
		})

		if err == nil {
			jsonPrint("new vector store", retVS)

			vectorStoreId = retVS.ID

			// upload knowledge file
			retFl, err := client.CreateFile(context.Background(), openai.FileRequest{
				FileName: "data.txt",
				FilePath: "data.txt",
				Purpose:  string(openai.PurposeAssistants),
			})

			if err == nil {
				jsonPrint("new file", retFl)

				// link file with vector store
				client.CreateVectorStoreFile(context.Background(), vectorStoreId, openai.VectorStoreFileRequest{
					FileID: retFl.ID,
				})
			} else {
				log.Println("Error create file :", err)
			}

			// link vector store with assistan
			client.ModifyAssistant(context.Background(), assistantId, openai.AssistantRequest{
				ToolResources: &openai.AssistantToolResource{
					FileSearch: &openai.AssistantToolFileSearch{
						VectorStoreIDs: []string{vectorStoreId},
					},
				},
			})
		} else {
			log.Println("Error create vector store :", err)
		}
	}

	if vectorStoreId == "" {
		log.Panicln("unable to init vector store")
	}
}

func initThread() {

	retThr, err := client.CreateThread(context.Background(), openai.ThreadRequest{})

	if err != nil {
		log.Panicln("unable to create thread")
	}

	threadId = retThr.ID
}

func runThread(question string) string {

	// add message to thread
	client.CreateMessage(context.Background(), threadId, openai.MessageRequest{
		Role:    openai.ChatMessageRoleUser,
		Content: question,
	})

	// run the thread with assistant
	retRun, err := client.CreateRun(context.Background(), threadId, openai.RunRequest{
		AssistantID: assistantId,
		Instructions: "answer the question from file search vector store." +
			"if answer is not found, response with 'The question is out of my scope'",
	})

	if err != nil {
		return ""
	}

	// wait until run is complete
	ret := ""

	for {

		runStatus, err := client.RetrieveRun(context.Background(), threadId, retRun.ID)

		if err != nil {
			return "error :" + err.Error()
		}

		switch runStatus.Status {
		case "completed":
			// get latest thread message generated by run
			listMsg, err := client.ListMessage(context.Background(), threadId, nil, nil, nil, nil)

			if err != nil {
				ret = err.Error()
			} else if len(listMsg.Messages) > 0 && len(listMsg.Messages[0].Content) > 0 {
				ret = listMsg.Messages[0].Content[0].Text.Value

				// remove anotation
				pos := strings.LastIndex(ret, "【")
				if pos > 0 {
					ret = ret[0 : pos-1]
				}
			} else {
				ret = "invalid response"
			}
		case "cancelled", "failed":
			ret = "failed"
		}

		if ret != "" {
			break
		}

		time.Sleep(500 * time.Millisecond)
	}

	return ret
}

func main() {

	client = openai.NewClient("[input your open-ai api key here]")

	initAssistant()
	initVectorStore()
	initThread()

	fmt.Println("Vector Store Example")
	fmt.Println("Type your question and press enter. Press ctrl-c to quit")
	fmt.Println("")

	// wait question from user
	for {

		buf := bufio.NewReader(os.Stdin)
		fmt.Print("Question ? ")
		question, err := buf.ReadString('\n')
		if err != nil {
			break
		}

		ans := runThread(question)
		fmt.Println(ans)
	}
}
